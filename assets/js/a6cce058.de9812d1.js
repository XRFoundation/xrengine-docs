"use strict";(self.webpackChunk_xrengine_docs=self.webpackChunk_xrengine_docs||[]).push([[8750],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),m=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=m(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=m(n),u=a,h=d["".concat(l,".").concat(u)]||d[u]||c[u]||i;return n?o.createElement(h,s(s({ref:t},p),{},{components:n})):o.createElement(h,s({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,s=new Array(i);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var m=2;m<i;m++)s[m]=n[m];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},20646:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return r},metadata:function(){return m},toc:function(){return p}});var o=n(87462),a=n(63366),i=(n(67294),n(3905)),s=["components"],r={id:"ecs",title:"Entity Component System Overview",sidebar_label:"Entity Component System Overview",slug:"/"},l=void 0,m={unversionedId:"modules/engine/ecs",id:"modules/engine/ecs",title:"Entity Component System Overview",description:"The following is largely from the ECSY documentation, but has been reformatted to reflect our functional API",source:"@site/docs/0_modules/engine/ecs.md",sourceDirName:"0_modules/engine",slug:"/",permalink:"/xrengine-docs/docs/",editUrl:"https://github.com/XRFoundation/XREngine/packages/docs/docs/0_modules/engine/ecs.md",tags:[],version:"current",frontMatter:{id:"ecs",title:"Entity Component System Overview",sidebar_label:"Entity Component System Overview",slug:"/"}},p=[{value:"Example",id:"example",children:[],level:2},{value:"Components",id:"components",children:[{value:"Single value components",id:"single-value-components",children:[],level:3},{value:"Component pooling",id:"component-pooling",children:[{value:"Custom Components",id:"custom-components",children:[],level:4},{value:"Disable Component Pooling",id:"disable-component-pooling",children:[],level:4},{value:"Custom Component Pooling",id:"custom-component-pooling",children:[],level:4}],level:3},{value:"System State Components",id:"system-state-components",children:[],level:3}],level:2},{value:"Entities",id:"entities",children:[{value:"Adding components",id:"adding-components",children:[],level:3},{value:"Accessing components and modify components",id:"accessing-components-and-modify-components",children:[],level:3},{value:"Removing components",id:"removing-components",children:[],level:3}],level:2},{value:"Systems",id:"systems",children:[{value:"Registering a system",id:"registering-a-system",children:[],level:3},{value:"Unregistering a system",id:"unregistering-a-system",children:[],level:3},{value:"Execution order",id:"execution-order",children:[],level:3}],level:2},{value:"Queries",id:"queries",children:[{value:"Query syntax",id:"query-syntax",children:[],level:3},{value:"Not operator",id:"not-operator",children:[],level:3},{value:"Reactive queries",id:"reactive-queries",children:[{value:"Added and removed",id:"added-and-removed",children:[],level:4},{value:"Changed",id:"changed",children:[],level:4}],level:3}],level:2},{value:"Entities and components life cycle",id:"entities-and-components-life-cycle",children:[],level:2}],c={toc:p};function d(e){var t=e.components,n=(0,a.Z)(e,s);return(0,i.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"The following is largely from the ECSY documentation, but has been reformatted to reflect our functional API")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ecsy.io/docs/manual/images/ECSY%20Architecture.svg",alt:"ECS architecture"})),(0,i.kt)("p",null,"Some common terms within ECS engines are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Entities: an object with an unique ID that can have multiple components attached to it."),(0,i.kt)("li",{parentName:"ul"},"Components: different facets of an entity. ex: geometry, physics, hit points.   Data is only stored in components."),(0,i.kt)("li",{parentName:"ul"},"Systems: do the actual work with in an application by processing entities and modifying their components."),(0,i.kt)("li",{parentName:"ul"},"Queries: used by systems to determine which entities they are interested in, based on the components the entities own.")),(0,i.kt)("p",null,"The usual workflow when building an ECS based application is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Create the ",(0,i.kt)("inlineCode",{parentName:"li"},"components")," that shape the data you need to use in your application."),(0,i.kt)("li",{parentName:"ul"},"Create ",(0,i.kt)("inlineCode",{parentName:"li"},"entities")," and attach ",(0,i.kt)("inlineCode",{parentName:"li"},"components")," to them."),(0,i.kt)("li",{parentName:"ul"},"Create the ",(0,i.kt)("inlineCode",{parentName:"li"},"systems")," that will use these ",(0,i.kt)("inlineCode",{parentName:"li"},"components")," to read and transform the data of these entities."),(0,i.kt)("li",{parentName:"ul"},"Execute all the systems each frame.")),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"Let's say we want to create a game where the player fights with wolves and dragons.\nWe will start by defining components that will be attached to entities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Walker")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Flyer")," for entities that will walk and fly (resp.)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Enemy")," for enemy entities."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Model3D")," for all the entities that will have a 3d Model.")),(0,i.kt)("p",null,"Then we use these components to define our main entities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"wolf"),": It's an ",(0,i.kt)("inlineCode",{parentName:"li"},"Enemy"),", can ",(0,i.kt)("inlineCode",{parentName:"li"},"walk")," and has a ",(0,i.kt)("inlineCode",{parentName:"li"},"model3D"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dragon"),": It's an ",(0,i.kt)("inlineCode",{parentName:"li"},"Enemy"),", can ",(0,i.kt)("inlineCode",{parentName:"li"},"fly")," and has a ",(0,i.kt)("inlineCode",{parentName:"li"},"model3D"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"player"),": It's an ",(0,i.kt)("inlineCode",{parentName:"li"},"Player"),", can ",(0,i.kt)("inlineCode",{parentName:"li"},"walk")," and has a ",(0,i.kt)("inlineCode",{parentName:"li"},"model3D"),".")),(0,i.kt)("p",null,"And finally we define the systems that will add the logic to the game:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Walk"),": It will modify the ",(0,i.kt)("inlineCode",{parentName:"li"},"Walker")," entities (",(0,i.kt)("inlineCode",{parentName:"li"},"Player")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Wolf"),") moving them around."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Fly"),": It will modify the ",(0,i.kt)("inlineCode",{parentName:"li"},"Flyer")," entities (",(0,i.kt)("inlineCode",{parentName:"li"},"Dragon"),") moving them around in the sky."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AI_Walk"),": It will modify the ",(0,i.kt)("inlineCode",{parentName:"li"},"Enemy")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Walker")," entities (",(0,i.kt)("inlineCode",{parentName:"li"},"Wolf"),") using AI techniques to compute the path they will follow."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Attack"),": It will implement all the logic for attacks between ",(0,i.kt)("inlineCode",{parentName:"li"},"Enemy")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"Player")," entities."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Draw"),": It will draw all the entities that has ",(0,i.kt)("inlineCode",{parentName:"li"},"Model3D")," component on the screen.")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ecsy.io/docs/manual/images/dragons.svg",alt:"Wolves and dragons example"})),(0,i.kt)("h2",{id:"components"},"Components"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Component")," is an object that can store data but should have not behaviour (As that should be handled by systems). There is not a mandatory way to define a component."),(0,i.kt)("p",null,"To create a component you must extend the ",(0,i.kt)("inlineCode",{parentName:"p"},"Component")," class and define a schema:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { Component } from '@xrengine/engine/src/classes/Component';\nimport { Types } from '@xrengine/engine/src/types/Types';\n\n\nclass ComponentA extends Component {}\n\nComponentA.schema = {\n  number: { type: Types.Number, default: 10 },\n  string: { type: Types.String, default: \"Hello\" }\n}\n")),(0,i.kt)("p",null,"The schema is used to set the default values of a component. ECSY also uses it to implement the default ",(0,i.kt)("inlineCode",{parentName:"p"},".copy()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".clone()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},".reset()")," methods. Setting the initial values of a component, and resetting them via ",(0,i.kt)("inlineCode",{parentName:"p"},".reset()")," are necessary for pooling. When you define a schema, you get this for free! Schemas can also be used for tooling and serialization, something we plan on covering in the future."),(0,i.kt)("p",null,"Each property in a schema represents a property on the component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const component = new ComponentA();\nconsole.log(component.number === 10); // true\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," field must be set for each property. Each type has a default value as well as ",(0,i.kt)("inlineCode",{parentName:"p"},".copy()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".clone()")," functions."),(0,i.kt)("p",null,"There are a few primitive types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Types.Number"),": Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Types.Boolean"),": Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Types.String"),": Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},'""'),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Types.Ref"),": Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"undefined"),". Copies by reference, not a deep clone."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Types.JSON"),": Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),". Copies/clones via ",(0,i.kt)("inlineCode",{parentName:"li"},"JSON.parse(JSON.stringify(src))"),", this is somewhat expensive but sometimes useful."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Types.Array"),": Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"[]"),". Copies/clones each item by value.")),(0,i.kt)("p",null,"You can also define your own types with ",(0,i.kt)("inlineCode",{parentName:"p"},"createType()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { createType, copyCopyable, cloneClonable } from '@xrengine/engine/src/types/Types';\n\nclass Vector2 {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n  }\n\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  copy(source) {\n    this.x = source.x;\n    this.y = source.y;\n    return this;\n  }\n\n  clone() {\n    return new Vector2().set(this.x, this.y);\n  }\n}\n\nexport const Vector2Type = createType({\n  name: \"Vector2\",\n  default: new Vector2(),\n  copy: copyCopyable,\n  clone: cloneClonable\n});\n")),(0,i.kt)("h3",{id:"single-value-components"},"Single value components"),(0,i.kt)("p",null,"Components could be made of multiple attributes, but sometimes they just contain a single attribute.\nIn these cases using the attribute's name to match the component's name may seem handy:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class Acceleration extends Component {}\n\nAcceleration.schema = {\n  acceleration: { type: Types.Number, default: 0.1 }\n};\n")),(0,i.kt)("p",null,"But when accessing the value it seems redundant to use two ",(0,i.kt)("inlineCode",{parentName:"p"},"acceleration")," references:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let acceleration = entity.getComponent(Acceleration).acceleration;\n")),(0,i.kt)("p",null,"We suggest to use ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," as the attribute name for these components as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class Acceleration extends Component {}\n\nAcceleration.schema = {\n  value: { type: Types.Number, default: 0.1 }\n};\n\nlet acceleration = entity.getComponent(Acceleration).value;\n")),(0,i.kt)("p",null,"Eventually we could end up adding some syntactic sugar for these type of components returning directly the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," attribute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let acceleration = entity.getComponentValue(Acceleration);\n")),(0,i.kt)("h3",{id:"component-pooling"},"Component pooling"),(0,i.kt)("p",null,"Usually the application will re3quire adding and removing components in real time. Allocating resources in a performance sensitive application is considered a bad pattern because the garbage collector will get called often and may impact performance.\nIn order to minimize it, components are pooled.\nThis means that every time a component is added to an entity:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"addComponent(entity, ComponentA)\n")),(0,i.kt)("p",null,"the engine will try to reuse a ",(0,i.kt)("inlineCode",{parentName:"p"},"ComponentA")," instance, from the pool of components previously created, and it won't allocate a new one instead.\nWhen releasing that component, by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"removeComponent(entity, ComponentA)"),", it will get returned to the pool, ready to be used by another entity."),(0,i.kt)("p",null,"The engine should know how to reset a component to its original state, if your component has the proper schema defined, the engine will do this for you."),(0,i.kt)("h4",{id:"custom-components"},"Custom Components"),(0,i.kt)("p",null,"Sometimes it's not possible to define a component with a schema. If you still want to get the benefits of object pooling or redefine how ",(0,i.kt)("inlineCode",{parentName:"p"},".copy()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".clone()")," work, you can override any or all of the methods on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Component")," class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class ColorArray extends Component {\n  /**\n   * The constructor should set the initial values for a component.\n   * Override this method to set your own initial values.\n   **/\n  constructor(props) {\n    // Pass false to disable using the schema for default values.\n    super(false);\n\n    // Set your own default values instead\n    this.value = [];\n  }\n\n  /**\n   * The copy method is used when copying properties from one component to another.\n   * Copy is used when copying/cloning entities/components, it is not used in component pooling.\n   * You can re-implement this method to increase performance or deal with complex data structures.\n   **/\n  copy(src) {\n    this.value.length = src.value.length;\n\n    for (let i = 0; i < src.value.length; i++) {\n      const srcColor = src.value[i];\n      const destColor = this.value[i];\n\n      destColor.r = srcColor.r;\n      destColor.g = srcColor.g;\n      destColor.b = srcColor.b;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clone returns a new, identical instance of a component.\n   * We don't need to override clone in this case. However, if you needed to pass an argument\n   * to the constructor, you could override clone to do so.\n   * \n   * clone() {\n   *  return new this.constructor().copy(this);\n   * }\n   **/\n\n  /**\n   * The reset method is used to reset the component back to it's initial state.\n   * It's used in component pools when a component is disposed. It can be called fairly often so it is a common method\n   * to optimize when you are adding/removing a lot of this type of component. You'll want to avoid memory allocation\n   * as much as possible in the reset method. Try to reuse existing data structures whenever possible.\n   **/\n  reset() {\n    this.value.forEach(color => {\n      color.r = 0;\n      color.g = 0;\n      color.b = 0;\n    });\n  }\n}\n")),(0,i.kt)("p",null,"In extreme cases, you may experience performance bottlenecks due to the default implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Component")," class. If you experience this, you can override that specific component with your own faster implementation."),(0,i.kt)("h4",{id:"disable-component-pooling"},"Disable Component Pooling"),(0,i.kt)("p",null,"In other cases you may want to disable component pooling altogether. Some components can't be copied or cloned properly."),(0,i.kt)("p",null,"In this case you can disable component pooling when you first register a component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'class AudioListener extends Component {\n  constructor(props) {\n    super(false);\n    this.listener = props.listener;\n  }\n\n  clone() {\n    throw new Error("unimplemented");\n  }\n\n  copy() {\n    throw new Error("unimplemented");\n  }\n\n  reset() {\n    throw new Error("unimplemented");\n  }\n}\n\n// Pass false to registerComponent to disable component pooling\nregisterComponent(AudioListener, false);\n')),(0,i.kt)("h4",{id:"custom-component-pooling"},"Custom Component Pooling"),(0,i.kt)("p",null,"Additionally, you can implement your own component pool or configure component pool settings by passing an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"ObjectPool")," as the second argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"registerComponent")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"import { ObjectPool } from 'ecsy';\n\n// Register MyComponent with an ObjectPool that has 1000 initial instances of MyComponent\nregisterComponent(MyComponent, new ObjectPool(MyComponent, 1000));\n\n// Use your own custom ObjectPool implementation\nclass MyObjectPool extends ObjectPool {\n  acquire() {\n    // Your implementation\n  }\n\n  release(item) {\n    // Your implementation\n  }\n\n  expand(count) {\n    // Your implementation\n  }\n}\n\nregisterComponent(MyComponent, new MyObjectPool(MyComponent, 1000));\n")),(0,i.kt)("h3",{id:"system-state-components"},"System State Components"),(0,i.kt)("p",null,"System State Components (SSC) are components used by a system to hold internal resources for an entity. They are not removed when you delete the entity, you must explicitly remove them when you are done with them.\nThey can be used to detect when an entity has been added or removed from a query."),(0,i.kt)("p",null,"SSC can be defined by extending ",(0,i.kt)("inlineCode",{parentName:"p"},"SystemStateComponent")," instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"Component"),". Once the SSC is defined, it can be used as any other component."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'class StateComponentGeometry extends SystemStateComponent {}\n\nStateComponentGeometry.schema = {\n  meshReference: { type: Types.Ref }\n};\n\nclass Geometry extends Component {}\n\nGeometry.schema = {\n  primitive: { type: Types.String, default: "box" }\n};\n')),(0,i.kt)("p",null,"In this example ",(0,i.kt)("inlineCode",{parentName:"p"},"StateComponentGeometry")," is used to store the mesh resources created as defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Geometry")," component.\nIf any other system removes that entity, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Geometry")," component will get removed but the ",(0,i.kt)("inlineCode",{parentName:"p"},"StateComponentGeometry"),' will remain "alive" so this system can detect it and free the mesh resources:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class GeometrySystem extends System {\n  init() {\n    return {\n      queries: {\n        added: { components: [Geometry, Not(StateComponentGeometry)] },\n        remove: { components: [Not(Geometry), StateComponentGeometry] },\n        normal: { components: [Geometry, StateComponentGeometry] },\n      }\n    };\n  },\n  execute() {\n    added.forEach(entity => {\n      var mesh = new Mesh(entity.getComponent(Geometry).primitive);\n      addComponent(entity, StateComponentGeometry, {mesh: mesh});\n    });\n\n    remove.forEach(entity => {\n      var component = entity.getComponent(StateComponentGeometry);\n      // free resources for the mesh\n      component.mesh.dispose();\n\n      removeComponent(entity, StateComponentGeometry);\n    });\n\n    normal.forEach(entity => {\n      // use entity and its components (Geometry and StateComponentGeometry) if needed\n    });\n  }\n}\n\nMySystem.queries = {\n  added: { components: [Geometry, Not(StateComponentGeometry)] },\n  remove: { components: [Not(Geometry), StateComponentGeometry] },\n  normal: { components: [Geometry, StateComponentGeometry] },\n};\n")),(0,i.kt)("h2",{id:"entities"},"Entities"),(0,i.kt)("p",null,"An entity is an object that has a unique ID. Its purpose is to group components together."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ecsy.io/docs/manual/images/entities.svg",alt:"Entities"})),(0,i.kt)("p",null,"Entities should be created within a ",(0,i.kt)("inlineCode",{parentName:"p"},"World")," context:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let entity = world.createEntity();\n")),(0,i.kt)("h3",{id:"adding-components"},"Adding components"),(0,i.kt)("p",null,"Once an entity is created, it is possible to add Components to it:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'class ComponentA {\n  constructor() {\n    this.number = 10;\n    this.string = "Hello";\n  }\n}\n\n// Add the component with the default values\naddComponent(entity, ComponentA);\n\n// Add the component replacing the default values\naddComponent(entity, ComponentA, {number: 20, string: "Hi"});\n')),(0,i.kt)("h3",{id:"accessing-components-and-modify-components"},"Accessing components and modify components"),(0,i.kt)("p",null,"Components can be accessed from an entity in two ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getComponent(Component)"),": Get the component for read only operations."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getMutableComponent(Component)"),": Get the component to modify its values.")),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"development")," mode is enabled it will throw an error if you try to modify a component accessed by ",(0,i.kt)("inlineCode",{parentName:"p"},"getComponent"),", but that error will not be thrown on release mode because of performance reasons."),(0,i.kt)("p",null,"These two access modes help to implement ",(0,i.kt)("inlineCode",{parentName:"p"},"reactive queries"),"(",(0,i.kt)("a",{parentName:"p",href:"/manual/Architecture?id=reactive-queries"},"more info"),"), which are basically lists of entities populated with components that have mutated somehow, without much overhead on the execution as we avoid using custom setters or proxies.\nThis means every time you request a mutable component, it will get marked as modified and systems listening for that will get notified accordingly.\nIt's important to notice that the component will get marked as modified even if you don't change any attribute on it, so try to use ",(0,i.kt)("inlineCode",{parentName:"p"},"getMutableComponent")," only when you know you will actually modify the component and use ",(0,i.kt)("inlineCode",{parentName:"p"},"getComponent")," otherwise."),(0,i.kt)("p",null,"Other positive side effects of these two modes are allowing automatic schedulers to analyze the code to parallelize it and making the code easily readable as we could understand how the system is acting on the components."),(0,i.kt)("h3",{id:"removing-components"},"Removing components"),(0,i.kt)("p",null,"Another common operation on entities is to remove components:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"removeComponent(entity, ComponentA);\n")),(0,i.kt)("p",null,"This will mark the component to be removed and will populate all the queues from the systems that are listening to that event, but the component itself won't be disposed until the end of the frame, we call it ",(0,i.kt)("inlineCode",{parentName:"p"},"deferred removal"),".\nThis is done so systems that need to react to it can still access the data of the components."),(0,i.kt)("p",null,"Once a component is removed from an entity, it is possible to access its contents, by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"getRemovedComponent(Component)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Global execution\nimport { execute } from \"@xrengine/engine/src/ecs/functions/EngineFunctions\";\n\nclass SystemFoo extends System {\n  execute() {\n    this.queries.boxes.removed.forEach(entity => {\n      let component = entity.getRemovedComponent(Box);\n      console.log('Component removed:', component, 'on entity: ', entity.id);\n    });\n\n    this.queries.boxes.results.forEach(entity => {\n      console.log('Iterating on entity: ', entity.id);\n    });\n  }\n}\n\nSystemFoo.queries = {\n  boxes: {\n    components: [ Box ],\n    removed: true // To listen for removed entities from the query\n  }\n}\n\nlet entity = createEntity();\naddComponent(Box);\nexecute(); // Execute frame 1\nremoveComponent(entity, Box);\nexecute(); // Execute frame 2\n")),(0,i.kt)("p",null,"This example will output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Frame 1:\n  - Iterating on entity: 1\nFrame 2:\n  - Component removed: box on entity: 1\n")),(0,i.kt)("p",null,"Any further ",(0,i.kt)("inlineCode",{parentName:"p"},"execute()")," will not log anything, since none of the queries are satisfied after the component ",(0,i.kt)("inlineCode",{parentName:"p"},"Box")," was removed from the entity."),(0,i.kt)("p",null,"Even if the deferred removal is the default behaviour, it is possible to remove a component immediately if needed, by passing a second parameter to ",(0,i.kt)("inlineCode",{parentName:"p"},"removeComponent(Component, forceImmediate)"),".\nAlthough this is not the recommended behaviour because it could lead to side effect if other systems need to access the removed component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// The component will get removed immediately\nremoveComponent(entity, ComponentA, true);\n")),(0,i.kt)("h2",{id:"systems"},"Systems"),(0,i.kt)("p",null,"Systems are used to transform data stored on the components. Usually each system defines one or more queries of entities and iterates through these lists per frame. ",(0,i.kt)("a",{parentName:"p",href:"/api/classes/system"},"API Reference")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://ecsy.io/docs/manual/images/systems.svg",alt:"Wolves and dragons"})),(0,i.kt)("p",null,"Every frame systems are executed and they create, remove or modify entities and components."),(0,i.kt)("p",null,"The system interface is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class SystemName extends System {\n  init() {}\n  execute(delta, time) {}\n}\n")),(0,i.kt)("p",null,"A system should always extends from the ",(0,i.kt)("inlineCode",{parentName:"p"},"System")," class and it can implement two functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"init()"),": This function is called when the system is registered in a world (Calling ",(0,i.kt)("inlineCode",{parentName:"li"},"registerSystem"),") and can be used to initialize anything the system needs."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"execute(deltaTime, elapsedTime)"),": It will get called each frame by default (unless a custom scheduler is being used). Usually it will be used to loop through the lists of entities from each query and process the value of theirs components.")),(0,i.kt)("p",null,"Systems could define one or more ",(0,i.kt)("a",{parentName:"p",href:"/manual/Architecture?id=queries"},"queries")," by setting the static ",(0,i.kt)("inlineCode",{parentName:"p"},"queries")," attribute:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"SystemName.queries = {\n  boxes: { components: [ Box ] },\n  spheres: { components: [ Sphere ] }\n};\n")),(0,i.kt)("p",null,"If a ",(0,i.kt)("inlineCode",{parentName:"p"},"queries")," attribute is defined, is it possible to access the entities matching these queries on the ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class SystemName extends System {\n  execute(delta, time) {\n    this.queries.boxes.results.forEach(entity => {\n      let box = entity.getComponent(Box);\n      // Do whatever you want with box\n    });\n\n    this.queries.Spheres.results.forEach(entity => {\n      let sphere = entity.getComponent(Sphere);\n      // Do whatever you want with Sphere\n    });\n  }\n}\n")),(0,i.kt)("p",null,"If there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"reactive query")," (A query that ",(0,i.kt)("em",{parentName:"p"},"listens")," for entities added or removed to it or which components has changed, ",(0,i.kt)("a",{parentName:"p",href:"/manual/Architecture?id=reactive-queries"},"more info"),") on the list of queries defined by a system, this system is called ",(0,i.kt)("inlineCode",{parentName:"p"},"reactive system")," as it will react to changes on the entities and its components."),(0,i.kt)("p",null,"If you plan to mutate the results of a query while you are iterating it (eg: adding or removing components that will not match the query structure anymore, or removing the entity itself) you should traverse the results in reverse order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let results = this.queries.queryA.results;\nfor (var i = 0; i < results.length; i++) {\n  let entity = results[i];\n  if (i === 1) {\n    // This will cause the results list to be mutated, results.length will be decremented and you won't reach the end elements.\n    entity.remove();\n  }\n}\n\n// The correct way to do it\nlet results = this.queries.queryA.results;\nfor (var i = results.length - 1; i >= 0; i++) {\n  let entity = results[i];\n  if (i === 1) {\n    // This will modify the length of the results but as we are moving backward it won't affect us\n    entity.remove();\n  }\n}\n")),(0,i.kt)("h3",{id:"registering-a-system"},"Registering a system"),(0,i.kt)("p",null,"Systems should be registered in a world in order to initialize them and add them to the default scheduler that will execute them on each frame."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"registerSystem(SystemClass);\n")),(0,i.kt)("h3",{id:"unregistering-a-system"},"Unregistering a system"),(0,i.kt)("p",null,"Systems can be unregistered, and they will get removed from the execution queue and the world. So if you want to use them again you need to register them again.\nIf you just want to temporaly disable its execution, you must use ",(0,i.kt)("inlineCode",{parentName:"p"},"System.stop()/play()")," instead."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"world.unregisterSystem(SystemClass);\n")),(0,i.kt)("h3",{id:"execution-order"},"Execution order"),(0,i.kt)("p",null,"By default systems are executed on the same order they are registered in the world:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"world\n  .registerSystem(SystemA)\n  .registerSystem(SystemB)\n  .registerSystem(SystemC);\n")),(0,i.kt)("p",null,"This will execute ",(0,i.kt)("inlineCode",{parentName:"p"},"SystemA > SystemB > SystemC"),"."),(0,i.kt)("p",null,"You can also control the order of execution by adding a ",(0,i.kt)("inlineCode",{parentName:"p"},"priority: Number")," attribute when registering them.\nBy default systems have ",(0,i.kt)("inlineCode",{parentName:"p"},"priority=0")," and they are sorted in ascending order. The lower the number the earlier the system will be executed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"world\n  .registerSystem(SystemA)\n  .registerSystem(SystemB, { priority: 2 })\n  .registerSystem(SystemC, { priority: -1 })\n  .registerSystem(SystemD)\n  .registerSystem(SystemE);\n")),(0,i.kt)("p",null,"This will result in the execution order: ",(0,i.kt)("inlineCode",{parentName:"p"},"SystemC > SystemA > SystemD > SystemE > SystemB"),"."),(0,i.kt)("h2",{id:"queries"},"Queries"),(0,i.kt)("p",null,"A query is a collection of entities that match some conditions based on the components they own.\nThe most common use case for queries is to define them in systems. This is also the recommended way as the engine could use that information to organize and optimize the execution of the systems and queries. Also if several queries are created with the same components, the ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryManager")," will just create a single query under the hood and reference it everywhere saving memory and computation."),(0,i.kt)("p",null,"A query is always updated with the entities that match the components' condition. Once the query is initialized it traverses the components groups to determine which entities should be added to it. But after that, entities will get added or removed from the query as components are being added or removed from them."),(0,i.kt)("h3",{id:"query-syntax"},"Query syntax"),(0,i.kt)("p",null,"The only mandatory field in a query is ",(0,i.kt)("inlineCode",{parentName:"p"},"components")," attribute which defines the list of components that an entity must have to be included in this query."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},"{\n  QueryName: {\n    components: ArrayOfComponents,\n    listen: {\n      added: Boolean,\n      removed: Boolean,\n      changed: Boolean | ArrayOfComponents\n    }\n  }\n}\n")),(0,i.kt)("p",null,"For example, defining a query containing all the entities that have both the components ",(0,i.kt)("inlineCode",{parentName:"p"},"Position")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Velocity"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"var query = {\n  positions: {\n    components: [ Position, Velocity ]\n  }\n};\n")),(0,i.kt)("h3",{id:"not-operator"},"Not operator"),(0,i.kt)("p",null,"It is also possible to include a ",(0,i.kt)("inlineCode",{parentName:"p"},"Not")," operator when defining a query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"SystemTest.queries = {\n  activeEnemies: {\n    components: [ Enemy, Not(Dead) ]\n  }\n};\n")),(0,i.kt)("p",null,"This will return all the entities that ",(0,i.kt)("strong",{parentName:"p"},"have")," a ",(0,i.kt)("inlineCode",{parentName:"p"},"Enemy")," component but ",(0,i.kt)("strong",{parentName:"p"},"do have not")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"Dead")," component."),(0,i.kt)("p",null,"This operator could be very useful as a factory pattern (",(0,i.kt)("a",{parentName:"p",href:"https://fernandojsg.github.io/ecsy/examples/factory/index.html"},"example"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"SystemTest.queries = {\n  playerUninitialized: {\n    components: [ Player, Not(Name) ]\n  }\n};\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"playerUnitialized")," query will have all the players that don't have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Name")," component yet, a system could get this list and add a random name to them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"queries.playerUnitialized.results.forEach(entity => {\n  addComponent(entity, Name, {value: getRandomName()});\n});\n")),(0,i.kt)("p",null,"And as soon as the component ",(0,i.kt)("inlineCode",{parentName:"p"},"Name")," is added to the player entity, that entity will disappear from the query."),(0,i.kt)("h3",{id:"reactive-queries"},"Reactive queries"),(0,i.kt)("p",null,"Using reactive queries make it possible to react to changes on entities and its components."),(0,i.kt)("h4",{id:"added-and-removed"},"Added and removed"),(0,i.kt)("p",null,"One common use case is to detect whenever an entity has been added or removed from a query. This can be done by just setting ",(0,i.kt)("inlineCode",{parentName:"p"},"added")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"removed")," attributes to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," on the query:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"SystemTest.queries = {\n  boxes: {\n    components: [ Box, Transform ],\n    listen: {\n      added: true,\n      removed: true\n    }\n  }\n};\n")),(0,i.kt)("p",null,"With that definition it will be possible to iterate through them on the ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class SystemTest extends System {\n  execute() {\n    var boxesQuery = this.queries.boxes;\n\n    // All the entities with `Box` and `Transform` components\n    boxesQuery.results.forEach(entity => {});\n\n    // All the entities added to the query since the last call\n    boxesQuery.added.forEach(entity => {});\n\n    // All the entities removed from the query since the last call\n    boxesQuery.removed.forEach(entity => {});\n  }\n}\n")),(0,i.kt)("p",null,"To avoid callbacks and asynchrony, which is a bad thing for cache and predictability reasons, entities are queued on the ",(0,i.kt)("inlineCode",{parentName:"p"},"added")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"removed")," lists but the system owning these lists will be able to process them just whenever the ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," method will get called.\nSo every time you call ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," you will have the list of all the entities added or removed since the last call. After the call has been executed these lists will be cleared."),(0,i.kt)("h4",{id:"changed"},"Changed"),(0,i.kt)("p",null,"Sometimes is interesting to detect that an entity or a specific component has changed. This means that any of the components from the entity that are part of the query have changed.\nDetecting these changes is tricky to do performantly. That is why we rely on the ",(0,i.kt)("inlineCode",{parentName:"p"},"entity.getMutableComponent")," function that marks the component as modified.\nThe syntax to detect if an entity has changed, is similar to the ones for ",(0,i.kt)("inlineCode",{parentName:"p"},"added")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"removed"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"SystemTest.queries = {\n  boxes: {\n    components: [ Box, Transform ],\n    listen: {\n      added: true,\n      removed: true,\n      changed: true  // Detect that any of the components on the query (Box, Transform) has changed\n    }\n  }\n};\n")),(0,i.kt)("p",null,"Similar to the previous example, we now can iterate on the ",(0,i.kt)("inlineCode",{parentName:"p"},"changed")," list of entities:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class SystemTest extends System {\n  execute() {\n    let boxesQuery = this.queries.boxes;\n\n    // All the entities with `Box` component\n    boxesQuery.results.forEach(entity => {});\n\n    // All the entities added to the query since the last call\n    boxesQuery.added.forEach(entity => {});\n\n    // All the entities removed from the query since the last call\n    boxesQuery.removed.forEach(entity => {});\n\n    // All the entities which Box or Transform components have changed since the last call\n    boxesQuery.changed.forEach(entity => {});\n  }\n}\n")),(0,i.kt)("p",null,"Defining ",(0,i.kt)("inlineCode",{parentName:"p"},"changed: true")," will populate the list if ",(0,i.kt)("strong",{parentName:"p"},"any")," of the components in the query have been modified. If you are just interested just in some specific components instead, you can define an array of components instead of the boolean value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"SystemTest.queries = {\n  boxes: {\n    components: [ Box, Transform ],\n    listen: {\n      added: true,\n      removed: true,\n      changed: [ Box ]  // Detect that the Box component has changed\n    }\n  }\n};\n\n// ...\n  boxesQuery.changed.forEach(entity => {}); // Box component has changed\n// ...\n")),(0,i.kt)("h2",{id:"entities-and-components-life-cycle"},"Entities and components life cycle"),(0,i.kt)("p",null,"By default ECSY uses deferred removal when removing an entity or a component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Deferred remove component\nremoveComponent(entity, Player);\n\n// Deferred remove entity\nentity.remove();\n")),(0,i.kt)("p",null,"It is possible to override that behaviour and remove the component and entity immediately by passing ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," as an additional parameter to both functions. However this is not recommended behaviour as it could lead to side effects, so it should be used with caution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Remove component immediately\nremoveComponent(entity, Player, true);\n\n// Remove entity immediately\nentity.remove(true);\n")),(0,i.kt)("p",null,"When a component or an entity is removed, one ",(0,i.kt)("inlineCode",{parentName:"p"},"to be removed")," flag is activated and the ",(0,i.kt)("inlineCode",{parentName:"p"},"reactive queries")," (",(0,i.kt)("a",{parentName:"p",href:"/manual/Architecture?id=reactive-queries"},"more info"),") listening for ",(0,i.kt)("inlineCode",{parentName:"p"},"removed")," events will get populated by them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'// Component to identify a wolf\nclass Wolf extends TagComponent {}\n\n// Component to store how long the wolf is sleeping \nclass Sleeping extends Component {}\n\nSleeping.schema = {\n  startSleepingTime: { type: Types.Number }\n}\n\n// This system will wake up sleeping wolves randomly\nclass SystemAwakeWolves extends System {\n  execute() {\n    this.queries.sleepingWolves.results.forEach(wolf => {\n      if (Math.random() > 0.5) {\n        wolf.removeComponent(Sleeping);\n      }\n    });\n  }\n}\nSystemAwakeWolves.queries = {\n  sleepingWolves: { components: [ Wolf, Sleeping ]}\n};\n\n// This system will implements wolf reactions after just being awake\nclass SystemWolfReactions extends System {\n  execute(delta, elapsedTime) {\n    this.queries.sleepingWolves.removed.forEach(wolf => {\n      // We have to check if the "Sleeping" component has been removed\n      // because if the "Wolf" component is removed instead, it will trigger\n      // also ths "removed" event as is not fulfilling the query anymore either\n      if (wolf.hasRemovedComponent(Sleeping)) {\n        let sleeping = wolf.getRemovedComponent(Sleeping);\n        let duration = elapsedTime - sleeping.startSleepingTime;\n        // Do whatever with the `duration` value\n        // eg: Make the wolf move slower if its was sleeping for so long\n      }\n    });\n  }\n}\nSystemWolfReactions.queries = {\n  sleepingWolves: {\n    components: [ Wolf, Sleeping ],\n    listen: {\n      removed: true\n    }\n  }\n};\n')),(0,i.kt)("p",null,"In the previous example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"SystemAwakeWolves")," randomly wakes up wolves by removing the ",(0,i.kt)("inlineCode",{parentName:"p"},"Sleeping")," component from them. The entities representing these wolves will get removed from its ",(0,i.kt)("inlineCode",{parentName:"p"},"sleepingWolves")," query.\nAs the ",(0,i.kt)("inlineCode",{parentName:"p"},"SystemWolfReactions")," has the same query as the ",(0,i.kt)("inlineCode",{parentName:"p"},"SystemAwakeWolves"),", the entity will also get removed from its query. Because the query is also ",(0,i.kt)("a",{parentName:"p",href:"/manual/Architecture?id=reactive-queries"},"reactive")," (",(0,i.kt)("inlineCode",{parentName:"p"},"removed: true"),"), the ",(0,i.kt)("inlineCode",{parentName:"p"},"sleepingWolves.removed")," will get populated with the wolves that were awake in the previous system.\nWhen iterating these removed entities, it is possible to access the removed ",(0,i.kt)("inlineCode",{parentName:"p"},"Sleeping")," component by using ",(0,i.kt)("inlineCode",{parentName:"p"},"getRemovedComponent"),".\nPlease notice that if immediate removal was used, instead of the default deferred method, the component will not be accessible to any systems after it."),(0,i.kt)("p",null,"This flow is exactly the same when removing entities instead of components. The entities and its components will still be available on the rest of the systems reacting to these deletions."))}d.isMDXComponent=!0}}]);